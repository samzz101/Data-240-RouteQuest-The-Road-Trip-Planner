# -*- coding: utf-8 -*-
"""NewAndHopefullyFinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17TTICG0FL5UfklAUIAp0n3Sl0Js6hwWn
"""
import sys

cities_coordinates = {
    'Vancouver': (49.2827, -123.1207),
    'Toronto': (43.6532, -79.3832),
    'Niagara Falls': (43.0896, -79.0849),
    'Montreal': (45.5017, -73.5673),
    'Whistler': (50.1163, -122.9574),
    'Quebec City': (46.8139, -71.2082),
    'Ottawa': (45.4215, -75.6972),
    # 'Okanagan Valley' and 'Vancouver Island' are regions, not specific cities.
    # Below are central coordinates for these regions.
    'Okanagan Valley': (49.8877, -119.4960),
    'Vancouver Island': (49.6506, -125.4495),
    'Yellowknife': (62.4540, -114.3718),
    'Squamish': (49.7016, -123.1558),
    # 'Halifax Region' is used, but here are the coordinates for Halifax.
    'Halifax': (44.6488, -63.5752),
    'Calgary': (51.0447, -114.0719),
    'Mont Tremblant': (46.1185, -74.5962),
    'Gananoque': (44.3306, -76.1619),
    'Whitehorse': (60.7212, -135.0568),
    'New York City': (40.7128, -74.0060),
    'Edmonton': (53.5461, -113.4938),
    'Kingston': (44.2312, -76.4860),
    'Kamloops': (50.6745, -120.3273),
    'Buffalo': (42.8864, -78.8784),
    'Fraser Lake': (54.0606, -124.8522),
    # 'Newfoundland' is a province, below is the coordinate for its capital, St. John's.
    'Newfoundland': (47.5615, -52.7126),
    'Markham': (43.8563, -79.3370),
    'Grand Falls-Windsor': (48.9368, -55.6619),
    'Peterborough': (44.3091, -78.3197),
    # 'Saint-Jean-de-lÎle-dOrléans': (46.8902, -70.8068),
    'North Vancouver': (49.3200, -123.0724),
    # 'Banff National Park' is a national park, below is the coordinate for the town of Banff.
    'Banff': (51.1784, -115.5708),
    'Trinity': (48.3665, -53.3598),
    'Boston': (42.3601, -71.0589),
    # 'Lake Louise' is a hamlet, below is the coordinate for the lake itself.
    'Lake Louise': (51.4254, -116.1773),
    'Fairbanks': (64.8378, -147.7164),
    'Charlottetown': (46.2382, -63.1311),
    'Port Rexton': (48.3962, -53.3335),
}

# Function to get coordinates by city name
def get_coordinates(city_name):
    return cities_coordinates.get(city_name)

# Ask the user to enter a city name
user_input1 = input("Please enter a starting city name: ")
user_input2 = input("Please enter a ending city name: ")
user_input3= input("Please enter the category of establishment you want to visit (Seperated by a comma): ")

# Normalize the user input to match the format of the dictionary keys
city_to_search1 = user_input1.strip().title()
city_to_search2 = user_input2.strip().title()

# Fetch the coordinates for the entered city name
coordinates1 = get_coordinates(city_to_search1)
coordinates2 = get_coordinates(city_to_search2)

# No need to print coordinates
if coordinates1:
     print("")
    # Pass 'coordinates' to the next bit of code
else:
    print(f"No coordinates found for {city_to_search1}. Please make sure the city name is spelled correctly.")
    sys.exit()

if coordinates2:
    print("")
    # Pass 'coordinates' to the next bit of code
else:
    print(f"No coordinates found for {city_to_search2}. Please make sure the city name is spelled correctly.")
    sys.exit()

#Displaying the route
import requests
import json

def calculate_route(start, end):
    # OpenRouteService API URL
    url = "https://api.openrouteservice.org/v2/directions/driving-car"

    # Parameters with start and end coordinates (longitude, latitude)
    params = {
        'start': f'{start[1]},{start[0]}',  # longitude, latitude
        'end': f'{end[1]},{end[0]}'
    }

    # Replace 'your-actual-api-key' with the actual API key you obtained
    headers = {'Authorization': '5b3ce3597851110001cf62489e6e1f5dc3ca4ebc83c9f381c4101f3f'}

    # Making a GET request to the API
    response = requests.get(url, params=params, headers=headers)

    # Returning the JSON response
    return response.json()


# Call the function with the start and end coordinates
route = calculate_route(coordinates1, coordinates2)

# No need to print the route
# # Printing the result
# print(route)

# Saving the route data to a JSON file
with open('route_data.json', 'w') as file:
    json.dump(route, file, indent=4)

# No need to print this as well
# print("Route data saved to 'route_data.json'")

#Storing the route detials in a CSV and JSON file

import requests
import csv

def calculate_route(start, end):
    # OpenRouteService API URL
    url = "https://api.openrouteservice.org/v2/directions/driving-car"

    # Parameters with start and end coordinates (longitude, latitude)
    params = {
        'start': f'{start[1]},{start[0]}',  # longitude, latitude
        'end': f'{end[1]},{end[0]}'
    }

    # Replace 'your-actual-api-key' with the actual API key you obtained
    headers = {'Authorization': '5b3ce3597851110001cf62489e6e1f5dc3ca4ebc83c9f381c4101f3f'}

    # Making a GET request to the API
    response = requests.get(url, params=params, headers=headers)

    # Returning the JSON response
    return response.json()


# Call the function with the Vancouver and Victoria coordinates
route = calculate_route(coordinates1, coordinates2)

# Extract the geometry coordinates and the steps from the route data
coordinates = route['features'][0]['geometry']['coordinates']
steps = route['features'][0]['properties']['segments'][0]['steps']

# Save the steps to a CSV file
with open('route_data.csv', 'w', newline='') as file:
    writer = csv.writer(file)
    # Write the header
    writer.writerow(['step', 'start_longitude', 'start_latitude', 'end_longitude', 'end_latitude', 'distance', 'duration'])

    # Write the data for each step
    for i, step in enumerate(steps):
        # Get the indices for the start and end way points
        start_index = step['way_points'][0]
        end_index = step['way_points'][1]

        # Get the start and end coordinates using the indices
        start_lon, start_lat = coordinates[start_index]
        end_lon, end_lat = coordinates[end_index] if end_index < len(coordinates) else coordinates[-1]

        # Other step information
        distance = step['distance']
        duration = step['duration']

        # Write the step data to the CSV
        writer.writerow([i, start_lon, start_lat, end_lon, end_lat, distance, duration])

# No need to print this as well
# print("Route data saved to 'route_data.csv'")

# import csv
# import geopy.distance

# def load_route_from_csv(csv_file_path):
#     route = []
#     with open(csv_file_path, mode='r') as infile:
#         reader = csv.DictReader(infile)
#         for row in reader:
#             lat, lon = float(row['start_latitude']), float(row['start_longitude'])
#             route.append((lat, lon))  # Note the order (lon, lat)
#     return route

# def load_poi_from_csv(csv_file_path):
#     pois = []
#     with open(csv_file_path, mode='r') as infile:
#         reader = csv.DictReader(infile)
#         for row in reader:
#             # Read the latitude and longitude directly from their columns
#             lat, lon = float(row['latitude']), float(row['longitude'])
#             pois.append({'name': row['name'], 'coords': (lat, lon)})  # Note the order (lon, lat)
#     return pois

# def find_matching_pois(route, pois, threshold_km=0.05):
#     matching_pois = []
#     for route_point in route:
#         # Validate route_point coordinates
#         if not (-180 <= route_point[0] <= 180) or not (-90 <= route_point[1] <= 90):
#             continue  # Skip invalid coordinates

#         for poi in pois:
#             # Validate POI coordinates
#             if not (-180 <= poi['coords'][0] <= 180) or not (-90 <= poi['coords'][1] <= 90):
#                 continue  # Skip invalid coordinates

#             distance = geopy.distance.distance(route_point, poi['coords']).km
#             if distance <= threshold_km:  # Threshold to account for small inaccuracies
#                 matching_pois.append(poi['name'])
#     return matching_pois

# # Assuming 'route_data.csv' contains the route coordinates
# route_csv_file_path = '/content/route_data.csv'  # Update with your actual file path
# route = load_route_from_csv(route_csv_file_path)

# # Assuming 'attraction_details_1.csv' contains the POIs
# pois_csv_file_path = '/content/drive/Shareddrives/DATA 240- Data Mining/Cleaned dataset and code/Canada /Data/attraaction_lat_long.csv'  # Update with your actual file path
# pois = load_poi_from_csv(pois_csv_file_path)

# matching_pois = find_matching_pois(route, pois)

# # Display the names of matching POIs
# for poi_name in matching_pois:
#     print(poi_name)

#Gives the POIs in a bounded area,
import csv

def load_route_from_csv(csv_file_path):
    route_coords = []
    with open(csv_file_path, mode='r') as infile:
        reader = csv.DictReader(infile)
        for row in reader:
            lat, lon = float(row['start_latitude']), float(row['start_longitude'])
            route_coords.append((lat, lon))  # Note the order (lat, lon)
    return route_coords

def load_poi_from_csv(csv_file_path):
    pois = []
    with open(csv_file_path, mode='r') as infile:
        reader = csv.DictReader(infile)
        for row in reader:
            lat, lon = float(row['latitude']), float(row['longitude'])
            pois.append({'name': row['name'], 'coords': (lat, lon)})  # Note the order (lat, lon)
    return pois

def find_pois_within_route_bounds(route_coords, pois):
    # Find min and max coordinates of the route to define a bounding box
    min_lat = min(route_coords, key=lambda x: x[0])[0]
    max_lat = max(route_coords, key=lambda x: x[0])[0]
    min_lon = min(route_coords, key=lambda x: x[1])[1]
    max_lon = max(route_coords, key=lambda x: x[1])[1]

    # Find POIs within the bounding box
    pois_within_bounds = []
    for poi in pois:
        poi_lat, poi_lon = poi['coords']
        if min_lat <= poi_lat <= max_lat and min_lon <= poi_lon <= max_lon:
            pois_within_bounds.append(poi['name'])

    return pois_within_bounds

# Load your route and POIs
route_csv_file_path = r'C:\Users\Siddharth\PycharmProjects\Datamining\route_data.csv'  # Update with your actual file path for the route
route_coords = load_route_from_csv(route_csv_file_path)

#Details_1
pois_csv_file_path = r'C:\Users\Siddharth\PycharmProjects\Datamining\full_cleaned.csv'  # Update with your actual file path for the POIs
pois = load_poi_from_csv(pois_csv_file_path)

# Find POIs within the route bounds
pois_within_bounds = find_pois_within_route_bounds(route_coords, pois)

# Display the names of POIs within the route bounds
# for poi_name in pois_within_bounds:
#     print(poi_name)

#Print POI with filters, Rating and Price

import csv

def load_route_from_csv(csv_file_path):
    route_coords = []
    with open(csv_file_path, mode='r') as infile:
        reader = csv.DictReader(infile)
        for row in reader:
            start_lat, start_lon = float(row['start_latitude']), float(row['start_longitude'])
            end_lat, end_lon = float(row['end_latitude']), float(row['end_longitude'])
            # Adding both the start and end coordinates of each segment
            route_coords.extend([(start_lat, start_lon), (end_lat, end_lon)])
    return route_coords

def load_poi_from_csv(csv_file_path):
    pois = []
    with open(csv_file_path, mode='r') as infile:
        reader = csv.DictReader(infile)
        for row in reader:
            lat, lon = float(row['latitude']), float(row['longitude'])
            pois.append({
                'name': row['name'],
                'coords': (lat, lon),
                'sentiment_rating': row['sentiment_rating'],
                'popularity_rating': row['popularity_rating'],
                'price_level': row['price_level']
            })
    return pois

def find_pois_within_route_bounds(route_coords, pois, keywords=None):
    # Find min and max coordinates of the route to define a bounding box
    min_lat = min(route_coords, key=lambda x: x[0])[0]
    max_lat = max(route_coords, key=lambda x: x[0])[0]
    min_lon = min(route_coords, key=lambda x: x[1])[1]
    max_lon = max(route_coords, key=lambda x: x[1])[1]

    # Find POIs within the bounding box that contain any of the keywords
    pois_within_bounds = []
    for poi in pois:
        poi_lat, poi_lon = poi['coords']
        if min_lat <= poi_lat <= max_lat and min_lon <= poi_lon <= max_lon:
            if keywords is None or any(keyword.lower() in poi['name'].lower() for keyword in keywords):
                pois_within_bounds.append((poi['name'], poi['sentiment_rating'], poi['popularity_rating'], poi['price_level']))

    return pois_within_bounds

# Load your route and POIs
route_csv_file_path = r'C:\Users\Siddharth\PycharmProjects\Datamining\route_data.csv'  # Update with your actual file path for the route
route_coords = load_route_from_csv(route_csv_file_path)

# Assuming pois_csv_file_paths is a list of paths to the CSV files
pois_csv_file_paths = r'C:\Users\Siddharth\PycharmProjects\Datamining\full_cleaned.csv'
pois = load_poi_from_csv(pois_csv_file_paths)

# Define the keywords you want to search for in POI names
keywords = [keyword.strip() for keyword in user_input3.split(',')]

# Find POIs within the route bounds
pois_within_bounds = find_pois_within_route_bounds(route_coords, pois, keywords)

# Display the names, ratings, and prices of POIs within the route bounds
print("In Price_level, 1 being the cheapest to 5 being the most expensive")
for poi in pois_within_bounds:
    print(f"Name: {poi[0]}, Sentiment: {poi[1]}, Popularity: {poi[2]}, Price Level: {poi[3]}")


#
# #Attempt at running a math problem to figure out a way to get POIs near the route
#
# import math
#
# def haversine(lat1, lon1, lat2, lon2):
#     R = 6371.0  # Earth radius in kilometers
#
#     dLat = math.radians(lat2 - lat1)
#     dLon = math.radians(lon2 - lon1)
#     a = math.sin(dLat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dLon/2)**2
#     c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))
#
#     distance = R * c
#     return distance
#
# def point_to_line_distance(point, start_point, end_point):
#     # point: (lat, lon)
#     # start_point: (lat, lon) of the start of the line segment
#     # end_point: (lat, lon) of the end of the line segment
#     p_lat, p_lon = point
#     s_lat, s_lon = start_point
#     e_lat, e_lon = end_point
#
#     # If the start and end points are the same, return the distance to the start point
#     if (s_lat, s_lon) == (e_lat, e_lon):
#         return haversine(p_lat, p_lon, s_lat, s_lon)
#
#     # Convert all coordinates to radians
#     p_lat, p_lon, s_lat, s_lon, e_lat, e_lon = map(math.radians, [p_lat, p_lon, s_lat, s_lon, e_lat, e_lon])
#
#     # Haversine distances
#     dist_to_start = haversine(p_lat, p_lon, math.degrees(s_lat), math.degrees(s_lon))
#     dist_to_end = haversine(p_lat, p_lon, math.degrees(e_lat), math.degrees(e_lon))
#     line_dist = haversine(math.degrees(s_lat), math.degrees(s_lon), math.degrees(e_lat), math.degrees(e_lon))
#
#     # Using the law of cosines to find the angle between the point and the line ends
#     angle = math.acos((dist_to_start**2 + line_dist**2 - dist_to_end**2) / (2 * dist_to_start * line_dist))
#
#     # If the angle is obtuse, return the shortest distance to the endpoints
#     if angle > math.pi / 2:
#         return dist_to_start
#
#     # Otherwise calculate the perpendicular distance to the line segment
#     perpendicular_dist = math.sin(angle) * dist_to_start
#     return perpendicular_dist
#
# def find_pois_near_route(route_coords, pois, max_distance_km):
#     pois_near_route = []
#
#     # Calculate distance for each POI to the route
#     for poi in pois:
#         poi_lat, poi_lon = poi['coords']
#         min_distance_to_route = float('inf')
#
#         # Check distance to each segment of the route
#         for i in range(len(route_coords) - 1):
#             segment_start = route_coords[i]
#             segment_end = route_coords[i + 1]
#             distance = point_to_line_distance((poi_lat, poi_lon), segment_start, segment_end)
#             min_distance_to_route = min(min_distance_to_route, distance)
#
#         # If the minimum distance is within the specified threshold, add to the list
#         if min_distance_to_route <= max_distance_km:
#             pois_near_route.append(poi['name'])
#
#     return pois_near_route
#
# # Define the maximum distance (in km) a POI can be from the route to be considered close
# max_distance_km = 5000  # for example, 10 km
#
# # Find POIs near the route
# pois_near_route = find_pois_near_route(route_coords, pois, max_distance_km)
#
# # Display the names of POIs near the route
# for poi_name in pois_near_route:
#     print(poi_name)
#
